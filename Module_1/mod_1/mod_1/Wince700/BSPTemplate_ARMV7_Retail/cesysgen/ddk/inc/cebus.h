//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// Module Name:  
//     CEBUS.h
// 
// Abstract: Provides Liberary for Bus Access.
// 
// Notes: 
//
#ifndef __CEBUS_H_
#define __CEBUS_H_
#include <ceddk.h>
#include <pm.h>

#define _BUSACCESS_CTL_CODE(_Function)  \
            CTL_CODE(FILE_DEVICE_BUS_EXTENDER, _Function, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_BUS_TRANSLATE_BUS_ADDRESS _BUSACCESS_CTL_CODE(1)
#define IOCTL_BUS_TRANSLATE_SYSTEM_ADDRESS _BUSACCESS_CTL_CODE(2)

#define IOCTL_BUS_GET_POWER_STATE   _BUSACCESS_CTL_CODE(3)
#define IOCTL_BUS_SET_POWER_STATE   _BUSACCESS_CTL_CODE(4)


#define IOCTL_BUS_GET_CONFIGURE_DATA    _BUSACCESS_CTL_CODE(5)
#define IOCTL_BUS_SET_CONFIGURE_DATA    _BUSACCESS_CTL_CODE(6)

#define IOCTL_BUS_ACTIVATE_CHILD    _BUSACCESS_CTL_CODE(16)
#define IOCTL_BUS_DEACTIVATE_CHILD  _BUSACCESS_CTL_CODE(17)
#define IOCTL_BUS_POSTINIT          _BUSACCESS_CTL_CODE(18)
#define IOCTL_BUS_ENABLE_CHILD      _BUSACCESS_CTL_CODE(19)
#define IOCTL_BUS_DISABLE_CHILD     _BUSACCESS_CTL_CODE(20)
#define IOCTL_BUS_IS_CHILD_ENABLE   _BUSACCESS_CTL_CODE(21)

#define IOCTL_BUS_IS_CHILD_REMOVED   _BUSACCESS_CTL_CODE(32)
#define IOCTL_BUS_NAME_PREFIX _BUSACCESS_CTL_CODE(33)

#define IOCTL_BUS_OEM_EXTENDER  0x800

typedef struct _CEDDK_BUS_POWER_STATE {
    CEDEVICE_POWER_STATE DevicePowerState;
    PVOID  lpReserved; // THis is reserved for future.
} CEDDK_BUS_POWER_STATE, *PCEDDK_BUS_POWER_STATE;

// Structure for Translate Bus Address.
typedef struct _CEDDK_BUS_TRANSLATE_BUS_ADDR {
    INTERFACE_TYPE  InterfaceType;
    ULONG BusNumber;
    PHYSICAL_ADDRESS BusAddress;
    ULONG AddressSpace;
    PHYSICAL_ADDRESS TranslatedAddress;
} CEDDK_BUS_TRANSLATE_BUS_ADDR,*PCEDDK_BUS_TRANSLATE_BUS_ADDR;

typedef struct _CEDDK_BUS_TRANSLATE_SYSTEM_ADDR {
    INTERFACE_TYPE  InterfaceType;
    ULONG BusNumber;
    PHYSICAL_ADDRESS SystemAddress;
    PHYSICAL_ADDRESS TranslatedAddress;
} CEDDK_BUS_TRANSLATE_SYSTEM_ADDR,*PCEDDK_BUS_TRANSLATE_SYSTEM_ADDR;

typedef struct _CEDDK_BUS_DEVICE_CONFIGURATION_DATA {
    DWORD dwSpace;
    DWORD dwOffset;
    DWORD dwLength;
    BYTE pBuffer[1];
} CEDDK_BUS_DEVICE_CONFIGURATION_DATA,*PCEDDK_BUS_DEVICE_CONFIGURATION_DATA ;

// Bus Extention for USB OTG
#define BUS_USBOTG_EXTENTION_FUNCTIONCODE 0x100
#define BUS_USBOTG_EXTENTION_FUNCTIONCODE_SIZE 0x40
#define IOCTL_BUS_USBOTG_BEGIN _BUSACCESS_CTL_CODE(BUS_USBOTG_EXTENTION_FUNCTIONCODE)
#define IOCTL_BUS_USBOTG_END   _BUSACCESS_CTL_CODE(BUS_USBOTG_EXTENTION_FUNCTIONCODE+BUS_USBOTG_EXTENTION_FUNCTIONCODE_SIZE-1)
// Bus Extention for SD
#define BUS_SD_EXTENTION_FUNCTIONCODE 0x140
#define BUS_SD_EXTENTION_FUNCTIONCODE_SIZE 0x40
#define IOCTL_BUS_SD_BEGIN _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE)
#define IOCTL_BUS_SD_END   _BUSACCESS_CTL_CODE(BUS_SD_EXTENTION_FUNCTIONCODE+BUS_SD_EXTENTION_FUNCTIONCODE_SIZE-1)
// USBD Extension code
#define BUS_USBD_EXTENTION_FUNCTIONCODE 0x180
#define BUS_USBD_EXTENTION_FUNCTIONCODE_SIZE 0x40
#define IOCTL_BUS_USBD_BEGIN _BUSACCESS_CTL_CODE(BUS_USBD_EXTENTION_FUNCTIONCODE)
#define IOCTL_BUS_USBD_END   _BUSACCESS_CTL_CODE(BUS_USBD_EXTENTION_FUNCTIONCODE+BUS_USBD_EXTENTION_FUNCTIONCODE_SIZE-1)

// USBD Extension code
#define BUS_SERVICES_EXTENTION_FUNCTIONCODE 0x1C0
#define BUS_SERVICES_EXTENTION_FUNCTIONCODE_SIZE 0x40
#define IOCTL_BUS_SERVICES_BEGIN _BUSACCESS_CTL_CODE(BUS_SERVICES_EXTENTION_FUNCTIONCODE)
#define IOCTL_BUS_SERVICES_END   _BUSACCESS_CTL_CODE(BUS_SERVICES_EXTENTION_FUNCTIONCODE+BUS_SERVICES_EXTENTION_FUNCTIONCODE_SIZE-1)
/* define in PKFuncs.h
#define _REFLECTORACCESS_CTL_CODE(_Function)  \
            CTL_CODE(FILE_DEVICE_REFLECTOR, _Function, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#define IOCTL_REF_INTERRUPT_INITIALIZE _REFLECTORACCESS_CTL_CODE(1)
typedef struct _REF_INTERRUPT_INTIALIZE_PARAM {
    DWORD   idInt;
    HANDLE  hEvent;
    LPVOID  pvData;
    DWORD   cbData;
} REF_INTERRUPTINITIALIZE_PARAM, *PREF_INTERRUPTINITIALIZE_PARAM ;

#define IOCTL_REF_INTERRUPT_DONE _REFLECTORACCESS_CTL_CODE(2)
// dwSysIntr only.

#define IOCTL_REF_INTERRUPT_DISABLE _REFLECTORACCESS_CTL_CODE(3)
// dwSysIntr only

#define IOCTL_REF_INTERRUPT_MASK _REFLECTORACCESS_CTL_CODE(4)
typedef struct _REF_INTERRUPT_MASK_PARAM {
    DWORD idInt;
    BOOL fDisable;
} REF_INTERRUPT_MASK_PARAM, *PREF_INTERRUPT_MASK_PARAM ;

#define IOCTL_REF_VIRTUAL_COPY _REFLECTORACCESS_CTL_CODE(5)
typedef struct _REF_VIRTUALCOPY_PARAM {
    LPVOID  lpvDest;
    LPVOID  lpvSrc;
    DWORD   cbSize;
    DWORD   fdwProtect;
} REF_VIRTUALCOPY_PARAM,*PREF_VIRTUALCOPY_PARAM;

#define IOCTL_REF_LOAD_INT_CHAIN_HANDLER _REFLECTORACCESS_CTL_CODE(6)
#define REF_DEVDLL_LEN 0x40
#define REF_DEVENTRY_LEN 0x40
typedef struct _REF_LOAD_INT_CHAIN_HANDLER {
    TCHAR   szIISRDll[REF_DEVDLL_LEN];
    TCHAR   szIISREntry[REF_DEVENTRY_LEN];
    BYTE    bIRQ;
} REF_LOAD_INT_CHAIN_HANDLER, *PREF_LOAD_INT_CHAIN_HANDLER;
// Output is Handle.

#define IOCTL_REF_FREE_INT_CHAIN_HANDLER _REFLECTORACCESS_CTL_CODE(7)
// Input is Handle

#define IOCTL_REF_CREATE_STATIC_MAPPING _REFLECTORACCESS_CTL_CODE(8)
typedef struct _REF_CREATE_STATIC_MAPPING {
    DWORD   dwPhysBase;
    DWORD   dwSize;
} REF_CREATE_STATIC_MAPPING, *PREF_CREATE_STATIC_MAPPING;
// Output PVOID static addresss.
#define IOCTL_REF_INT_CHAIN_HANDLER_IOCONTROL _REFLECTORACCESS_CTL_CODE(9)
typedef struct _REF_INT_CHAIN_HANDLER_IOCONTROL {
    HANDLE  hLib;
    DWORD   dwIoControlCode;
    LPVOID  lpInBuf; // yes we use embedded pointer here.
    DWORD   nInBufSize;
} REF_INT_CHAIN_HANDLER_IOCONTROL, *PREF_INT_CHAIN_HANDLER_IOCONTROL;
// OUTPUT is IOCONTROL output buffer.
#define IOCTL_REF_CREATE_ASYNC_IO_HANDLE _REFLECTORACCESS_CTL_CODE(0xa)
// INPUT is NUNLL.
// OUTPUT is IOCONTROL output buffer.
typedef struct _REF_CREATE_ASYNC_IO_HANDLE {
    HANDLE  hIoRef;
    LPVOID  lpInBuf; // output value for async buffer.
    LPVOID  lpOutBuf; // outout value for async buffer.
} REF_CREATE_ASYNC_IO_HANDLE, *PREF_CREATE_ASYNC_IO_HANDLE;
*/
//  Beside Interupt function the MnMapFunction.
#define IOCTL_REF_MNMAPIOSPACE _REFLECTORACCESS_CTL_CODE(0x10)
typedef struct _REF_MNMAPIOSPACE_PARAM {
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG NumberOfBytes;
    BOOLEAN CacheEnable;
} REF_MNMAPIOSPACE_PARAM , *PREF_MNMAPIOSPACE_PARAM  ;

#define IOCTL_REF_MNUNMAPIOSPACE _REFLECTORACCESS_CTL_CODE(0x11)
typedef struct _REF_MNUNMAPIOSPACE_PARAM {
    PVOID BaseAddress;
    ULONG NumberOfBytes;
} REF_MNUNMAPIOSPACE_PARAM ,*PREF_MNUNMAPIOSPACE_PARAM ;

// CeDriverDuplicateCallerHandle
#define IOCTL_REF_DUPLCATE_HANDLE _REFLECTORACCESS_CTL_CODE(0x12)
typedef struct _REF_DUPLICATE_HANDLE_PARAM { // IN Put.
  HANDLE DirectCallerHandle;
  DWORD dwDesiredAccess;
  BOOL bInheritHandle; 
  DWORD dwOptions;
} REF_DUPLICATE_HANDLE_PARAM,*PREF_DUPLICATE_HANDLE_PARAM;
// OUTPUT Buffer is Handle.


#endif

